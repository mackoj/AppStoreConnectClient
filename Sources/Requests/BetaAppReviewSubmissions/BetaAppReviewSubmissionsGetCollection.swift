//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

#if canImport(AppStoreConnectModels)
  import AppStoreConnectModels
  import AppStoreConnectSharedCode
#endif

extension AppStoreConnect.BetaAppReviewSubmissions {

  public enum BetaAppReviewSubmissionsGetCollection {

    public static let service = APIService<Response>(
      id: "betaAppReviewSubmissions-get_collection", tag: "BetaAppReviewSubmissions", method: "GET",
      path: "/v1/betaAppReviewSubmissions", hasBody: false,
      securityRequirement: SecurityRequirement(type: "itc-bearer-token", scopes: []))

    /** filter by attribute 'betaReviewState' */
    public enum ASCFilterbetaReviewState: String, Codable, Equatable, CaseIterable {
      case waitingForReview = "WAITING_FOR_REVIEW"
      case inReview = "IN_REVIEW"
      case rejected = "REJECTED"
      case approved = "APPROVED"
    }

    /** the fields to include for returned resources of type betaAppReviewSubmissions */
    public enum ASCFieldsbetaAppReviewSubmissions: String, Codable, Equatable, CaseIterable {
      case betaReviewState = "betaReviewState"
      case build = "build"
    }

    /** comma-separated list of relationships to include */
    public enum ASCInclude: String, Codable, Equatable, CaseIterable {
      case build = "build"
    }

    /** the fields to include for returned resources of type builds */
    public enum ASCFieldsbuilds: String, Codable, Equatable, CaseIterable {
      case app = "app"
      case appEncryptionDeclaration = "appEncryptionDeclaration"
      case appStoreVersion = "appStoreVersion"
      case betaAppReviewSubmission = "betaAppReviewSubmission"
      case betaBuildLocalizations = "betaBuildLocalizations"
      case betaGroups = "betaGroups"
      case buildBetaDetail = "buildBetaDetail"
      case diagnosticSignatures = "diagnosticSignatures"
      case expirationDate = "expirationDate"
      case expired = "expired"
      case iconAssetToken = "iconAssetToken"
      case icons = "icons"
      case individualTesters = "individualTesters"
      case minOsVersion = "minOsVersion"
      case perfPowerMetrics = "perfPowerMetrics"
      case preReleaseVersion = "preReleaseVersion"
      case processingState = "processingState"
      case uploadedDate = "uploadedDate"
      case usesNonExemptEncryption = "usesNonExemptEncryption"
      case version = "version"
    }

    public final class Request: APIRequest<Response> {

      public struct Options {

        /** filter by attribute 'betaReviewState' */
        public var filterbetaReviewState: [ASCFilterbetaReviewState]?

        /** filter by id(s) of related 'build' */
        public var filterbuild: [String]

        /** the fields to include for returned resources of type betaAppReviewSubmissions */
        public var fieldsbetaAppReviewSubmissions: [ASCFieldsbetaAppReviewSubmissions]?

        /** maximum resources per page */
        public var limit: Int?

        /** comma-separated list of relationships to include */
        public var include: [ASCInclude]?

        /** the fields to include for returned resources of type builds */
        public var fieldsbuilds: [ASCFieldsbuilds]?

        public init(
          filterbetaReviewState: [ASCFilterbetaReviewState]? = nil, filterbuild: [String],
          fieldsbetaAppReviewSubmissions: [ASCFieldsbetaAppReviewSubmissions]? = nil,
          limit: Int? = nil, include: [ASCInclude]? = nil, fieldsbuilds: [ASCFieldsbuilds]? = nil
        ) {
          self.filterbetaReviewState = filterbetaReviewState
          self.filterbuild = filterbuild
          self.fieldsbetaAppReviewSubmissions = fieldsbetaAppReviewSubmissions
          self.limit = limit
          self.include = include
          self.fieldsbuilds = fieldsbuilds
        }
      }

      public var options: Options

      public init(options: Options) {
        self.options = options
        super.init(service: BetaAppReviewSubmissionsGetCollection.service)
      }

      /// convenience initialiser so an Option doesn't have to be created
      public convenience init(
        filterbetaReviewState: [ASCFilterbetaReviewState]? = nil, filterbuild: [String],
        fieldsbetaAppReviewSubmissions: [ASCFieldsbetaAppReviewSubmissions]? = nil,
        limit: Int? = nil, include: [ASCInclude]? = nil, fieldsbuilds: [ASCFieldsbuilds]? = nil
      ) {
        let options = Options(
          filterbetaReviewState: filterbetaReviewState, filterbuild: filterbuild,
          fieldsbetaAppReviewSubmissions: fieldsbetaAppReviewSubmissions, limit: limit,
          include: include, fieldsbuilds: fieldsbuilds)
        self.init(options: options)
      }

      public override var queryParameters: [String: Any] {
        var params: [String: Any] = [:]
        if let filterbetaReviewState = options.filterbetaReviewState?.encode().map({
          String(describing: $0)
        }).joined(separator: ",") {
          params["filter[betaReviewState]"] = filterbetaReviewState
        }
        params["filter[build]"] = options.filterbuild.joined(separator: ",")
        if let fieldsbetaAppReviewSubmissions = options.fieldsbetaAppReviewSubmissions?.encode()
          .map({ String(describing: $0) }).joined(separator: ",")
        {
          params["fields[betaAppReviewSubmissions]"] = fieldsbetaAppReviewSubmissions
        }
        if let limit = options.limit {
          params["limit"] = limit
        }
        if let include = options.include?.encode().map({ String(describing: $0) }).joined(
          separator: ",")
        {
          params["include"] = include
        }
        if let fieldsbuilds = options.fieldsbuilds?.encode().map({ String(describing: $0) }).joined(
          separator: ",")
        {
          params["fields[builds]"] = fieldsbuilds
        }
        return params
      }
    }

    public enum Response: APIResponseValue, CustomStringConvertible, CustomDebugStringConvertible {
      public typealias SuccessType = ASCBetaAppReviewSubmissionsResponse

      /** List of BetaAppReviewSubmissions */
      case status200(ASCBetaAppReviewSubmissionsResponse)

      /** Parameter error(s) */
      case status400(ASCErrorResponse)

      /** Forbidden error */
      case status403(ASCErrorResponse)

      public var success: ASCBetaAppReviewSubmissionsResponse? {
        switch self {
        case .status200(let response): return response
        default: return nil
        }
      }

      public var failure: ASCErrorResponse? {
        switch self {
        case .status400(let response): return response
        case .status403(let response): return response
        default: return nil
        }
      }

      /// either success or failure value. Success is anything in the 200..<300 status code range
      public var responseResult:
        APIResponseResult<ASCBetaAppReviewSubmissionsResponse, ASCErrorResponse>
      {
        if let successValue = success {
          return .success(successValue)
        } else if let failureValue = failure {
          return .failure(failureValue)
        } else {
          fatalError("Response does not have success or failure response")
        }
      }

      public var response: Any {
        switch self {
        case .status200(let response): return response
        case .status400(let response): return response
        case .status403(let response): return response
        }
      }

      public var statusCode: Int {
        switch self {
        case .status200: return 200
        case .status400: return 400
        case .status403: return 403
        }
      }

      public var successful: Bool {
        switch self {
        case .status200: return true
        case .status400: return false
        case .status403: return false
        }
      }

      public init(statusCode: Int, data: Data, decoder: ResponseDecoder) throws {
        switch statusCode {
        case 200:
          self = try .status200(
            decoder.decode(ASCBetaAppReviewSubmissionsResponse.self, from: data))
        case 400: self = try .status400(decoder.decode(ASCErrorResponse.self, from: data))
        case 403: self = try .status403(decoder.decode(ASCErrorResponse.self, from: data))
        default: throw APIClientError.unexpectedStatusCode(statusCode: statusCode, data: data)
        }
      }

      public var description: String {
        return "\(statusCode) \(successful ? "success" : "failure")"
      }

      public var debugDescription: String {
        var string = description
        let responseString = "\(response)"
        if responseString != "()" {
          string += "\n\(responseString)"
        }
        return string
      }
    }
  }
}
